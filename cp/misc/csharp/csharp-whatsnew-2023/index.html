<!doctype html><html><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-QZ9N5F5QDD"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-QZ9N5F5QDD")</script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>C# 言語アップデートで使えるようになった新機能 2023 (.NET 5～7) &ndash; Growth Record of Lettuce Farm: Extended</title><meta name=description property="og:description" content="2023 年の AtCoder 言語アップデートで新しく使えるようになった C# の機能について、競技プログラミングの観点で使えそうなものをピックアップします。 Native AOT 新しいコンパイル方式で、ネイティブのバイナリに変換してくれます。理論上 C++ 並みの実行速度を期待できるので、 C#er にとってはこの上ない福音でしょう。 問題に|れたすのブログ"><meta name=apple-mobile-web-app-title content="Growth Record of Lettuce Farm: Extended"><link rel=icon href=https://blog.fairy-lettuce.com/favicon-64.png><link rel=apple-touch-icon href=https://blog.fairy-lettuce.com/apple-touch-icon.png><link rel=mask-icon size=any href=https://blog.fairy-lettuce.com/pinned-icon.svg><meta name=twitter:card content="summary"><meta name=twitter:site content="@fairy_lettuce"><meta name=twitter:creator content="@fairy_lettuce"><meta name=twitter:title content="C# 言語アップデートで使えるようになった新機能 2023 (.NET 5～7) | Growth Record of Lettuce Farm: Extended"><meta name=twitter:description content="2023 年の AtCoder 言語アップデートで新しく使えるようになった C# の機能について、競技プログラミングの観点で使えそうなものをピックアップします。 Native AOT 新しいコンパイル方式で、ネイティブのバイナリに変換してくれます。理論上 C++ 並みの実行速度を期待できるので、 C#er にとってはこの上ない福音でしょう。 問題に|れたすのブログ"><meta name=twitter:image content="https://blog.fairy-lettuce.com/twitter-card.png"><link rel=stylesheet href=/assets/syntax.css><link rel=stylesheet href=/assets/primer-build.css><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/assets/custom_style.css></head><body class=bg-gray><div id=holy class="container-lg bg-white h-100"><div id=header class="px-1 bg-white"><nav class="UnderlineNav UnderlineNav--right px-2"><a class="UnderlineNav-actions muted-link h2" href=https://blog.fairy-lettuce.com/>Growth Record of Lettuce Farm: Extended</a><div class=UnderlineNav-body><a class=UnderlineNav-item href=/about><i class='fa fa-about'></i>
<span>About</span></a>
<a class=UnderlineNav-item href=/diary><i class='fa fa-diary'></i>
<span>Diary</span></a>
<a class=UnderlineNav-item href=/cp><i class='fa fa-cp'></i>
<span>Competitive</span></a>
<a class=UnderlineNav-item href=/links><i class='fa fa-diary-old'></i>
<span>Links</span></a>
<a class=UnderlineNav-item href=https://github.com/fairy-lettuce><i class='fa fa-github'></i>
<span>GitHub</span></a></div></nav></div><div role=main id=main class="holy-main markdown-body px-4 bg-white"><div class=Subhead><div class=Subhead-heading><div class="h1 mt-3 mb-1">C# 言語アップデートで使えるようになった新機能 2023 (.NET 5～7)</div></div><div class=Subhead-description><a href=/categories/atcoder class=muted-link><span class="Label Label--gray-darker">AtCoder</span></a>
<a href=/categories/competitive class=muted-link><span class="Label Label--gray-darker">Competitive</span></a>
<a href=/categories/%E7%AB%B6%E3%83%97%E3%83%AD%E3%81%9D%E3%81%AE%E4%BB%96 class=muted-link><span class="Label Label--gray-darker">競プロその他</span></a>
<a href=/tags/c class=muted-link><span class="Label Label--gray">C#</span></a><div class=float-md-right><span title="Lastmod: 2023-08-22. Published at: 2023-08-22.">Published: 2023-08-22</span></div></div></div><article><section class="pb-6 mb-3 border-bottom"><p>2023 年の AtCoder 言語アップデートで新しく使えるようになった C# の機能について、競技プログラミングの観点で使えそうなものをピックアップします。</p><h2 id=native-aot>Native AOT</h2><p>新しいコンパイル方式で、ネイティブのバイナリに変換してくれます。理論上 C++ 並みの実行速度を期待できるので、 C#er にとってはこの上ない福音でしょう。</p><p>問題にもよりますが、C++ と C# (JIT) の間くらいの実行時間になります。もちろん、旧来のコンパイル方式 (JIT) も利用可能です。</p><p>JIT コンパイルの場合は ML.NET という機械学習用ライブラリが使用可能です。AtCoder で ML.NET がどれくらい輝くかは未知数です。</p><h2 id=generic-math>Generic Math</h2><p>ジェネリックで四則演算や論理演算 (bitwise XOR なんかも使える) を呼び出すことができます！！！！セグ木、ModInt、行列累乗あたりのライブラリが整備しやすくなります。</p><p>ジェネリックとは任意の型に対してクラスやメソッド等を定義できる機能のことです。</p><p>ジェネリックにて使う型に特定の機能を持っていてほしい場合は、その機能を示すインターフェースを明示する必要があります。そうすることでインターフェースを実装するクラスのみをジェネリック型に取れます。</p><p>しかし、今までの C# には四則演算や論理演算などに対するインターフェースは存在しかったので、そのような演算を抽象化する場合には面倒な書き方を強いられていました。</p><p>(たとえば、readonly struct に必要な演算を入れることや、<a href=https://ufcpp.net/study/csharp/sp3_expression.html>式木 Expression Tree</a> を用いる方法が有名でした。)</p><p>.NET 7 / C# 11.0 以降は数値演算のインターフェースが定義できるようになったので、例えば「和を取れる型 <code>T</code> の <code>IEnumerable&lt;T></code> に対する総和を求める」とか「総和じゃなくて総 XOR を求める」とかも簡単にできるようになります。</p><p>ビット演算、和の単位元や積の単位元、果ては三角関数などもあり、至れり尽くせり。</p><p>膨大な量のインターフェースが存在しており、詳しく書くと非常に面倒です。調べたときには別記事を書くかもしれません。</p><h2 id=top-level-statement>Top-level statement</h2><p>C# 9.0 まではプログラムで最初に実行する文 (エントリーポイント) は <code>Main()</code> 関数でないといけませんでした。</p><p>しかし、C# 10.0 以降は Python のようなスクリプト言語かのように、何もないところに処理を突然書けるようになりました。</p><p>こういうことが C# のコードとして許されるわけです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span>Console.WriteLine(<span style=color:#e6db74>&#34;Hello World!&#34;</span>);
</span></span></code></pre></div><p>ABC-A/B くらいの問題ならたった数行で AC できます。意味不明すぎる。もはやスクリプト言語。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>var</span> a = Console.ReadLine().Split().Select(p =&gt; <span style=color:#66d9ef>int</span>.Parse(p)).ToArray();
</span></span><span style=display:flex><span>Console.WriteLine(a[<span style=color:#ae81ff>0</span>] * a[<span style=color:#ae81ff>1</span>] % <span style=color:#ae81ff>2</span> == <span style=color:#ae81ff>0</span> ? <span style=color:#e6db74>&#34;Even&#34;</span> : <span style=color:#e6db74>&#34;Odd&#34;</span>);
</span></span></code></pre></div><p><a href=https://atcoder.jp/contests/language-test-202301/submissions/44839386>https://atcoder.jp/contests/language-test-202301/submissions/44839386</a></p><p>Implicit usings というのがあるので基本的な機能なら using もいらないらしいです。</p><p><a href=https://ufcpp.net/blog/2021/11/implicitusings/>https://ufcpp.net/blog/2021/11/implicitusings/</a></p><h2 id=priority-queue>Priority queue</h2><p>これが C# では今まで存在しなかった。嘘でしょ？</p><p>最小四分ヒープであり、優先度の小さい順に取り出されます。また、 <strong><code>ac-library-csharp</code> と異なり要素を優先度と同一視しない</strong> ( <code>ac-library-csharp</code> では要素と優先度が同じ) ので、要素と優先度を必ず指定する必要があります。使い方が異なることに要注意です。</p><p>また、優先度は <code>Dequeue()</code> や <code>Peek()</code> によって参照できないので競技プログラミング的には不便かもしれません。</p><p>ただし、 <code>TryDequeue()</code> や <code>TryPeek()</code> では取得できるので、ちょっと面倒ですが優先度を見たいときはこっちを使いましょう。</p><table><thead><tr><th>メソッド</th><th>時間計算量</th></tr></thead><tbody><tr><td>要素を事前に与えるコンストラクタ</td><td>$O(N)$</td></tr><tr><td><code>Enqueue()</code></td><td>$O(\log N)$</td></tr><tr><td><code>Dequeue()</code></td><td>$O(\log N)$</td></tr><tr><td><code>Peek()</code></td><td>$O(1)$</td></tr></tbody></table><p>要素を事前に与えるコンストラクタは heapify というアルゴリズムを使用していて、要素を一つ一つ <code>Enqueue()</code> する ($O(N\log N)$) よりも効率が良いです。</p><p>また、 <code>EnqueueDequeue()</code> という <code>Enqueue()</code> する直後に <code>Dequeue()</code> する操作を定数倍良く実装するメソッドもあります。</p><h2 id=ac-library-csharp>ac-library-csharp</h2><p>AtCoder Library の C# 移植版です。現在 <a href=https://github.com/kzrnm>kzrnm さん</a> が管理されています。</p><p><a href=https://github.com/kzrnm/ac-library-csharp>https://github.com/kzrnm/ac-library-csharp</a> にて公開されています。NuGet でもインストールできます。</p><p>今回のアップデート以降、AtCoder 上では <code>using AtCoder;</code> を宣言するだけで使えるので便利になりました。</p><h2 id=linq-新メソッド>LINQ 新メソッド</h2><p>.NET 6 で新しく LINQ のメソッドがたくさん追加されました。</p><p><a href=https://learn.microsoft.com/ja-jp/dotnet/core/whats-new/dotnet-6#new-linq-apis>https://learn.microsoft.com/ja-jp/dotnet/core/whats-new/dotnet-6#new-linq-apis</a></p><p><code>TryGetNonEnumeratedCount()</code> 以外は競プロでの用途があると思います。</p><p>以下、詳しく各メソッドの解説をします。<code>IEnumerable&lt;T></code> を指して「配列」と呼んでいますがご容赦ください。</p><h3 id=trygetnonenumeratedcount><code>TryGetNonEnumeratedCount()</code></h3><p>ご存知の通り、 <code>IEnumerable&lt;T></code> は遅延評価により LINQ 等のメソッドを評価しています。遅延セグ木と全く同じで、データ変更クエリはデータ参照クエリが来たときに初めて展開・評価する仕組みになっています。</p><p>このメソッドでは遅延評価なしに要素数を参照できる (厳密には <code>ICollections&lt;T></code> を実装する) ならその要素数を取得し、できないならその旨を報告します。</p><p>C#/.NET は実行時エラーを避けるためのセーフな関数をたくさん用意するので、納得はできる関数です。でも競技プログラミングではあまり使わなさそう。</p><h3 id=chunk><code>Chunk()</code></h3><p>配列の要素を一定の個数ごとに分割するのを一発でしてくれるメソッドです。平方分割に使えそう。</p><h3 id=maxby-minby><code>MaxBy(), MinBy()</code></h3><p><code>OrderBy()</code> のように、配列の要素からキーへの写像を与えることで、その写像を適用した値を基準にして最大値・最小値を求めることができます。</p><p>写像だけでなく、比較するための関数を <code>IComparer&lt;T></code> で与えることもできます。</p><p>これも活用例がたくさん思いつきますね。タプルのリスト <code>List&lt;(int a, int b)> list</code> について、 <code>b</code> が最大値を取る要素の <code>a</code> は <code>list.MaxBy(p => p.b).a</code> で書けます。すごく使えそう。</p><h3 id=distinctby><code>DistinctBy()</code></h3><p>競プロ C#er みんな大好き <code>Distinct()</code> がキー指定できるようになって帰ってきた！</p><p><code>MaxBy(), MinBy()</code> 同様、要素のキーを指定して重複する値を削除するメソッドです。これも便利そうですね。</p><h3 id=exceptby-intersectby-unionby><code>ExceptBy(), IntersectBy(), UnionBy()</code></h3><p>それぞれ差集合、積集合、和集合をキー指定して求められます。</p><p>覚えておくとたまに使えそう？</p><h3 id=elementat-elementatordefault><code>ElementAt(), ElementAtOrDefault()</code></h3><p><code>IEnumerable&lt;T></code> の <code>index</code> 番目の要素を取得できます。</p><p>絶対メソッドチェーン使うマン向けの機能です。</p><p>また、 <code>ElementAtOrDefault()</code> は配列外参照したらその型のデフォルト値を返します。競技プログラミングならこれを使わずデバッガーで確認したほうが楽だし、余計にバグの原因になると思います。</p><h3 id=firstordefault-lastordefault><code>FirstOrDefault(), LastOrDefault()</code></h3><p>配列の最初の値・最後の値 (または引数で与えた条件を満たす要素のうち最初の値・最後の値) を返す関数です。</p><p>元の配列が空、もしくは該当する要素が存在しない場合には型で定められた既定値を返すのですが、指定した値を規定値に設定することができるようになりました。逆に今までなんでなかったんだろう。</p><h3 id=singleordefault><code>SingleOrDefault()</code></h3><p>要素数 1 の配列の要素 (または引数で与えた条件を満たす唯一の要素) を返す関数です。先程のメソッドと同様の機能が追加されました。</p><p>競技プログラミングだと微妙に使わないかもしれない。</p><h3 id=max-min><code>Max(), Min()</code></h3><p><code>IComparer&lt;T></code> を与えることで好きな比較関数を用いて最大値・最小値を計算できるようになりました。地味に便利。</p><h3 id=take><code>Take()</code></h3><p>配列の <code>start</code> から <code>end</code> 番目の範囲を抜き出すには <code>Take()</code> と <code>Skip()</code> を組み合わせる必要がありましたが、 <code>Take()</code> の引数に <code>Range</code> 構造体を与えることで一発でできるようになりました。</p><h3 id=zip><code>Zip()</code></h3><p>今まで 2 つの配列をまとめることしかできませんでしたが、3 つの配列をまとめられるようになります。</p><p>ただ、3 つをまとめる場合は現時点では残念ながらタプルにまとめることしかできないようです。</p><h2 id=正規表現のパフォーマンス強化>正規表現のパフォーマンス強化</h2><p>稀に使えるかもしれない。</p><h2 id=datetime-のマイクロ秒ナノ秒サポート>DateTime のマイクロ秒・ナノ秒サポート</h2><p>競技プログラミングでも時間を測って実行したい場面があると思います。あるいは乱数のシードにミリ秒まで入れた時刻を入れたいこともあるかと思います。</p><p>今まではミリ秒・マイクロ秒を求めるには <code>Ticks</code> プロパティから逐一計算する必要がありましたが、その必要がなくなりました。やった！</p></section><section></section></article></div><div id=side class="pr-1 bg-white"><aside class=pr-3><div id=author class="Box mb-3 mt-3 p-2 text-center"><a href=/about><img class=m-1 src=/icon-round.png alt=プロフィール画像 width=120 height=120></a><p class="text-emphasized f3">れたす</p><p>遊んだこと・学んだことをまとめる個人ブログ</p><a href=https://twitter.com/fairy_lettuce>Twitter</a></div><div id=toc class="Box Box--blue mb-3"><b>C# 言語アップデートで使えるようになった新機能 2023 (.NET 5～7)</b><nav id=TableOfContents><ul><li><a href=#native-aot>Native AOT</a></li><li><a href=#generic-math>Generic Math</a></li><li><a href=#top-level-statement>Top-level statement</a></li><li><a href=#priority-queue>Priority queue</a></li><li><a href=#ac-library-csharp>ac-library-csharp</a></li><li><a href=#linq-新メソッド>LINQ 新メソッド</a><ul><li><a href=#trygetnonenumeratedcount><code>TryGetNonEnumeratedCount()</code></a></li><li><a href=#chunk><code>Chunk()</code></a></li><li><a href=#maxby-minby><code>MaxBy(), MinBy()</code></a></li><li><a href=#distinctby><code>DistinctBy()</code></a></li><li><a href=#exceptby-intersectby-unionby><code>ExceptBy(), IntersectBy(), UnionBy()</code></a></li><li><a href=#elementat-elementatordefault><code>ElementAt(), ElementAtOrDefault()</code></a></li><li><a href=#firstordefault-lastordefault><code>FirstOrDefault(), LastOrDefault()</code></a></li><li><a href=#singleordefault><code>SingleOrDefault()</code></a></li><li><a href=#max-min><code>Max(), Min()</code></a></li><li><a href=#take><code>Take()</code></a></li><li><a href=#zip><code>Zip()</code></a></li></ul></li><li><a href=#正規表現のパフォーマンス強化>正規表現のパフォーマンス強化</a></li><li><a href=#datetime-のマイクロ秒ナノ秒サポート>DateTime のマイクロ秒・ナノ秒サポート</a></li></ul></nav></div><div><a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class=twitter-share-button data-show-count=false>Tweet</a><script async src=https://platform.twitter.com/widgets.js></script>
<iframe src="https://www.facebook.com/plugins/share_button.php?href=https%3A%2F%2Fdevelopers.facebook.com%2Fdocs%2Fplugins%2F&layout=button&size=small&mobile_iframe=true&width=61&height=20&appId" width=61 height=20 style=border:none;overflow:hidden scrolling=no frameborder=0 allowtransparency=true allow=encrypted-media></iframe>
<a href=http://b.hatena.ne.jp/entry/ class=hatena-bookmark-button data-hatena-bookmark-layout=basic-label-counter data-hatena-bookmark-lang=ja title=このエントリーをはてなブックマークに追加><img src=https://b.st-hatena.com/images/entry-button/button-only@2x.png alt=このエントリーをはてなブックマークに追加 width=20 height=20 style=border:none></a><script type=text/javascript src=https://b.st-hatena.com/js/bookmark_button.js async></script>
<a data-pocket-label=pocket data-pocket-count=none class=pocket-btn data-lang=en></a>
<script type=text/javascript>!function(e,t){if(!e.getElementById(t)){var s,n=e.createElement("script");n.id=t,n.src="https://widgets.getpocket.com/v1/j/btn.js?v=1",s=e.getElementById(t),e.body.appendChild(n)}}(document,"pocket-btn-js")</script></div></aside></div><div id=footer class="pt-2 pb-3 bg-white text-center"><span class="text-small text-gray">©fairy-lettuce 2023 &#183;
Powered by the
<a href=https://github.com/qqhann/hugo-primer class=link-gray-dark>Hugo-Primer</a> theme for
<a href=https://gohugo.io class=link-gray-dark>Hugo</a>.</span></div></div><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script></body></html>